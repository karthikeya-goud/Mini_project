import numpy as np
import random
import pandas as pd
import matplotlib.pyplot as plt
import pickle
import networkx as nx
import folium

# Step 1: Define Custom 12 Locations (latitude, longitude for each location)
locations = [
    {"Location ID": 1, "Latitude": 40.7128, "Longitude": -74.0060},  # New York
    {"Location ID": 2, "Latitude": 34.0522, "Longitude": -118.2437},  # Los Angeles
    {"Location ID": 3, "Latitude": 51.5074, "Longitude": -0.1278},  # London
    {"Location ID": 4, "Latitude": 48.8566, "Longitude": 2.3522},  # Paris
    {"Location ID": 5, "Latitude": 35.6762, "Longitude": 139.6503},  # Tokyo
    {"Location ID": 6, "Latitude": 39.9042, "Longitude": 116.4074},  # Beijing
    {"Location ID": 7, "Latitude": -33.8688, "Longitude": 151.2093},  # Sydney
    {"Location ID": 8, "Latitude": 40.7306, "Longitude": -73.9352},  # Brooklyn
    {"Location ID": 9, "Latitude": 48.2082, "Longitude": 16.3738},  # Vienna
    {"Location ID": 10, "Latitude": 41.9028, "Longitude": 12.4964},  # Rome
    {"Location ID": 11, "Latitude": 37.7749, "Longitude": -122.4194},  # San Francisco
    {"Location ID": 12, "Latitude": 52.5200, "Longitude": 13.4050},  # Berlin
]

traffic_conditions = ["Low", "Medium", "High"]
ad_types = ["Banner", "Video", "Interactive"]
times_of_day = ["Morning", "Afternoon", "Evening"]

# Simulate ad engagement based on traffic and ad type
def simulate_engagement(traffic_condition, ad_type):
    traffic_factor = {"Low": 1, "Medium": 2, "High": 3}
    ad_factor = {"Banner": 1, "Video": 2, "Interactive": 3}
    base_engagement = random.uniform(1, 5)  # Base engagement between 1 and 5
    return base_engagement * traffic_factor[traffic_condition] * ad_factor[ad_type] / 10

# Step 2: Create a graph for the locations (12 nodes)
G = nx.Graph()

# Adding nodes (locations)
for loc in locations:
    G.add_node(loc["Location ID"], pos=(loc["Latitude"], loc["Longitude"]))

# Create edges between nodes with random engagement as the weight
for i in range(len(locations)):
    for j in range(i+1, len(locations)):
        loc_i = locations[i]["Location ID"]
        loc_j = locations[j]["Location ID"]
        
        # Random traffic condition and ad type for each edge
        traffic_condition = random.choice(traffic_conditions)
        ad_type = random.choice(ad_types)
        
        # Simulate engagement for the edge (path between two locations)
        engagement = simulate_engagement(traffic_condition, ad_type)
        
        # Add edge with engagement as the weight
        G.add_edge(loc_i, loc_j, weight=engagement)

# Step 3: Find the shortest path based on engagement
def find_best_path(G, source, destination):
    # Use Dijkstra's algorithm to find the best path maximizing engagement (highest weight)
    # Note: We want to maximize engagement, so we negate the weight to find the highest-weight path
    path = nx.dijkstra_path(G, source, destination, weight="weight")
    path_weight = nx.dijkstra_path_length(G, source, destination, weight="weight")
    return path, path_weight

# Example: Find the best path from New York (1) to Tokyo (5)
source = 1  # New York
destination = 5  # Tokyo
best_path, engagement = find_best_path(G, source, destination)

print(f"Best path from {source} to {destination}: {best_path} with engagement: {engagement}")

# Step 4: Visualization (Map view)
# Create a folium map centered around the average location
average_lat = np.mean([loc["Latitude"] for loc in locations])
average_lon = np.mean([loc["Longitude"] for loc in locations])

map = folium.Map(location=[average_lat, average_lon], zoom_start=2)

# Add markers for the locations
for loc in locations:
    folium.Marker(
        location=[loc["Latitude"], loc["Longitude"]],
        popup=f"Location {loc['Location ID']}",
    ).add_to(map)

# Plot the path on the map
for i in range(len(best_path) - 1):
    loc1 = best_path[i]
    loc2 = best_path[i + 1]
    
    # Get coordinates of the locations
    lat1, lon1 = locations[loc1 - 1]["Latitude"], locations[loc1 - 1]["Longitude"]
    lat2, lon2 = locations[loc2 - 1]["Latitude"], locations[loc2 - 1]["Longitude"]
    
    # Add a line to represent the path between locations
    folium.PolyLine([(lat1, lon1), (lat2, lon2)], color="blue", weight=2.5, opacity=1).add_to(map)

# Save the map as an HTML file
map.save("best_path_map.html")

# Step 5: Visualization (Bar Plot for ad types)
action_counts = {action: 0 for action in ad_types}
for state in G.edges:
    engagement = G[state[0]][state[1]]["weight"]
    if engagement > 0:
        action_counts["Banner"] += 1  # Example count for a specific ad type

plt.bar(action_counts.keys(), action_counts.values())
plt.title("Ad Type Frequency in Training (Exploration/Exploitation)")
plt.xlabel("Ad Type")
plt.ylabel("Frequency")
plt.show()
