import cv2
import numpy as np
import os

def calculate_optical_flow_magnitude(prev_frame, current_frame):
    """
    Calculate the optical flow magnitude between two consecutive frames.
    """
    flow = cv2.calcOpticalFlowFarneback(prev_frame, current_frame, None, 0.5, 3, 15, 3, 5, 1.2, 0)
    magnitude, _ = cv2.cartToPolar(flow[..., 0], flow[..., 1])
    return np.sum(magnitude)

def extract_significant_frames_with_motion_diff(video_path, num_frames_before=15, num_frames_after=15):
    """
    This function reads a video, calculates the motion difference between consecutive frames,
    and selects frames around the largest motion difference.
    """
    video = cv2.VideoCapture(video_path)
    total_frames = int(video.get(cv2.CAP_PROP_FRAME_COUNT))

    prev_frame = None
    motion_differences = []

    # Loop through frames to calculate optical flow and motion differences
    for i in range(1, total_frames):
        ret, frame = video.read()
        if not ret:
            break
        
        gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        
        if prev_frame is not None:
            # Calculate motion difference (optical flow magnitude change)
            motion_diff = calculate_optical_flow_magnitude(prev_frame, gray_frame)
            motion_differences.append((i, motion_diff))

        prev_frame = gray_frame

    video.release()

    # Find the frame with the maximum motion difference
    max_motion_frame = max(motion_differences, key=lambda x: x[1])

    # Get the index of the frame with the highest motion difference
    max_frame_index = max_motion_frame[0]

    # Calculate the start and end indices for the window of frames around the maximum motion frame
    start_frame = max_frame_index - num_frames_before
    end_frame = max_frame_index + num_frames_after

    # Ensure the frames are within the valid range
    start_frame = max(0, start_frame)
    end_frame = min(total_frames - 1, end_frame)

    # Collect the frames within the window
    selected_frames = []
    video = cv2.VideoCapture(video_path)
    video.set(cv2.CAP_PROP_POS_FRAMES, start_frame)
    
    for i in range(start_frame, end_frame + 1):
        ret, frame = video.read()
        if ret:
            selected_frames.append(frame)
        else:
            break

    video.release()

    return selected_frames

def process_dataset(dataset_path, output_path, num_frames_before=15, num_frames_after=15):
    """
    Process the entire dataset, extracts frames around the highest motion change for each video,
    and saves the frames to disk.
    """
    os.makedirs(output_path, exist_ok=True)

    for label_folder in os.listdir(dataset_path):
        label_folder_path = os.path.join(dataset_path, label_folder)

        if os.path.isdir(label_folder_path):
            label_output_path = os.path.join(output_path, label_folder)
            os.makedirs(label_output_path, exist_ok=True)

            for video_name in os.listdir(label_folder_path):
                video_path = os.path.join(label_folder_path, video_name)

                if os.path.isfile(video_path) and video_path.endswith('.mp4'):
                    print(f"Processing {video_name}...")

                    # Extract frames around the largest motion difference
                    significant_frames = extract_significant_frames_with_motion_diff(video_path, num_frames_before, num_frames_after)

                    # Save the selected frames for LSTM input (directly store in the label folder)
                    output_video_path = os.path.join(label_output_path, f"{video_name.replace('.mp4', '')}_frames.npy")
                    np.save(output_video_path, np.array(significant_frames))

                    # Free memory after processing
                    del significant_frames

    print("Dataset processing complete!")

# Example usage:
dataset_path = 'path_to_your_dataset'  # Path to your dataset
output_path = 'path_to_output_folder'  # Path to store processed frames

process_dataset(dataset_path, output_path, num_frames_before=15, num_frames_after=15)





import os
import numpy as np

def load_data(dataset_root):
    data = []
    labels = []

    # Iterate through each action class folder
    for class_name in os.listdir(dataset_root):
        class_folder = os.path.join(dataset_root, class_name)
        if os.path.isdir(class_folder):
            # Iterate through each video file in the class folder
            for video_file in os.listdir(class_folder):
                video_file_path = os.path.join(class_folder, video_file)
                if os.path.isfile(video_file_path) and video_file.endswith('_frames.npy'):
                    # Load the frames (numpy array)
                    frames = np.load(video_file_path)

                    # Append frames and their corresponding label (action class)
                    data.append(frames)
                    labels.append(class_name)  # The action class is the label

    return np.array(data), np.array(labels)

# Example usage
dataset_root = 'path_to_your_dataset'  # Replace with the actual path
data, labels = load_data(dataset_root)
print(data.shape, labels.shape)
