import cv2
import numpy as np
import os

def resize_and_normalize_frame(frame, target_size=(224, 224)):
    """
    Resize and normalize the frame.
    """
    # Resize the frame
    resized_frame = cv2.resize(frame, target_size)
    
    # Normalize the frame: Scale pixel values to the range [0, 1]
    normalized_frame = resized_frame / 255.0  # Normalize to [0, 1]
    
    return normalized_frame

def extract_significant_frames_with_motion_diff(video_path, total_frames_to_extract=90, fps_required=30, apply_clahe=False):
    """
    This function reads a video, calculates the motion difference between consecutive frames,
    and selects a total of 90 frames centered around the frame with the highest motion difference.
    It also checks for FPS and ensures the video has more than 90 frames.
    Optionally applies CLAHE for night-time video enhancement.
    """
    video = cv2.VideoCapture(video_path)
    
    # Get FPS and check if it's the required FPS
    fps = video.get(cv2.CAP_PROP_FPS)
    if fps != fps_required:
        print(f"Skipping {video_path}: FPS is {fps}, expected {fps_required}.")
        return None

    # Get total number of frames and ensure there are more than 90 frames
    total_frames = int(video.get(cv2.CAP_PROP_FRAME_COUNT))
    if total_frames <= 90:
        print(f"Skipping {video_path}: Video has only {total_frames} frames, requires more than 90 frames.")
        return None

    prev_frame = None
    motion_differences = []

    # Loop through frames to calculate optical flow and motion differences
    for i in range(1, total_frames):
        ret, frame = video.read()
        if not ret:
            break
        
        # Optionally apply CLAHE for night-time enhancement
        if apply_clahe:
            frame = apply_clahe_to_frame(frame)
        
        # Calculate motion difference (optical flow magnitude change)
        gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)  # Convert to grayscale for optical flow calculation
        if prev_frame is not None:
            motion_diff = calculate_optical_flow_magnitude(prev_frame, gray_frame)
            motion_differences.append((i, motion_diff))  # Store the frame index and its motion difference

        prev_frame = gray_frame

    video.release()

    # Find the frame with the maximum motion difference
    if not motion_differences:
        print(f"No motion differences found for {video_path}.")
        return None

    max_motion_frame = max(motion_differences, key=lambda x: x[1])  # x[1] is the motion difference value

    # Get the index of the frame with the highest motion difference
    max_frame_index = max_motion_frame[0]

    # Calculate the start and end indices for the window of frames around the maximum motion frame
    num_frames_before = (total_frames_to_extract - 1) // 2
    num_frames_after = total_frames_to_extract - num_frames_before - 1

    start_frame = max_frame_index - num_frames_before
    end_frame = max_frame_index + num_frames_after

    # Ensure the frames are within the valid range
    start_frame = max(0, start_frame)
    end_frame = min(total_frames - 1, end_frame)

    # Collect the frames within the window
    selected_frames = []
    video = cv2.VideoCapture(video_path)
    video.set(cv2.CAP_PROP_POS_FRAMES, start_frame)
    
    for i in range(start_frame, end_frame + 1):
        ret, frame = video.read()
        if ret:
            # Resize and normalize each frame
            processed_frame = resize_and_normalize_frame(frame)
            selected_frames.append(processed_frame)
        else:
            break

    video.release()

    return selected_frames

def save_frames_to_npy(frames, output_npy_path):
    """
    Save the selected frames to an output .npy file.
    """
    if not frames:
        print(f"No frames to save for {output_npy_path}.")
        return

    # Convert frames list to a numpy array
    frames_array = np.array(frames)

    # Print the shape of the array before saving
    print(f"Saving frames with shape: {frames_array.shape} at {output_npy_path}")

    # Save to .npy file
    try:
        np.save(output_npy_path, frames_array)
        print(f"Frames saved at: {output_npy_path}")
    except Exception as e:
        print(f"Error saving frames: {e}")

def process_videos_in_directory(input_dir, output_dir, total_frames_to_extract=90, fps_required=30, apply_clahe=False, videos_per_folder=None):
    """
    Process all videos in a directory, extract exactly 90 frames around the highest motion change
    for each video, resize and normalize the frames, and save the frames to .npy files in the corresponding output directory.
    """
    # Iterate over each action class folder
    for class_folder in os.listdir(input_dir):
        class_folder_path = os.path.join(input_dir, class_folder)
        
        if not os.path.isdir(class_folder_path):
            continue  # Skip if not a directory (e.g., a file)

        # Create a corresponding output directory for the current action class
        class_output_dir = os.path.join(output_dir, class_folder)
        os.makedirs(class_output_dir, exist_ok=True)

        # Process a limited number of videos per folder
        video_files = [f for f in os.listdir(class_folder_path) if f.endswith('.mp4')]
        if videos_per_folder:
            video_files = video_files[:videos_per_folder]  # Limit to the first N videos

        # Process each video in the action class folder
        for video_file in video_files:
            video_path = os.path.join(class_folder_path, video_file)

            print(f"Processing {video_file}...")

            # Extract exactly 90 frames around the largest motion difference
            significant_frames = extract_significant_frames_with_motion_diff(video_path, total_frames_to_extract, fps_required, apply_clahe)

            # If the video is valid (i.e., has the correct FPS and more than 90 frames), save the frames
            if significant_frames is not None:
                output_npy_path = os.path.join(class_output_dir, f"{video_file.replace('.mp4', '')}_frames_{total_frames_to_extract}.npy")
                print(f"Saving frames for {video_file} to {output_npy_path}")
                save_frames_to_npy(significant_frames, output_npy_path)

                # Free memory after processing
                del significant_frames

    print("Processing complete!")

# Example usage:
input_dir = '/path_to_dataset'  # Path to the dataset folder containing labeled subfolders
output_dir = '/path_to_output_folder'  # Path to store .npy files
videos_per_folder = 3  # Specify the number of videos to process per folder (e.g., 3)

# Process all videos in the dataset and store the extracted frames as .npy files
# Set apply_clahe=True to apply CLAHE enhancement for night-time videos
process_videos_in_directory(input_dir, output_dir, total_frames_to_extract=90, fps_required=30, apply_clahe=True, videos_per_folder=videos_per_folder)
