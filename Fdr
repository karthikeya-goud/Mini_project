import numpy as np
import random
import pandas as pd
import matplotlib.pyplot as plt
import pickle
import networkx as nx
import folium
from math import radians, sin, cos, sqrt, atan2

# Step 1: Define Custom 12 Locations (latitude, longitude for each location)
locations = [
    {"Location ID": 1, "Latitude": 40.7128, "Longitude": -74.0060},  # New York
    {"Location ID": 2, "Latitude": 34.0522, "Longitude": -118.2437},  # Los Angeles
    {"Location ID": 3, "Latitude": 51.5074, "Longitude": -0.1278},  # London
    {"Location ID": 4, "Latitude": 48.8566, "Longitude": 2.3522},  # Paris
    {"Location ID": 5, "Latitude": 35.6762, "Longitude": 139.6503},  # Tokyo
    {"Location ID": 6, "Latitude": 39.9042, "Longitude": 116.4074},  # Beijing
    {"Location ID": 7, "Latitude": -33.8688, "Longitude": 151.2093},  # Sydney
    {"Location ID": 8, "Latitude": 40.7306, "Longitude": -73.9352},  # Brooklyn
    {"Location ID": 9, "Latitude": 48.2082, "Longitude": 16.3738},  # Vienna
    {"Location ID": 10, "Latitude": 41.9028, "Longitude": 12.4964},  # Rome
    {"Location ID": 11, "Latitude": 37.7749, "Longitude": -122.4194},  # San Francisco
    {"Location ID": 12, "Latitude": 52.5200, "Longitude": 13.4050},  # Berlin
]

# Function to calculate distance between two locations using the Haversine formula
def haversine(lat1, lon1, lat2, lon2):
    # Radius of the Earth in km
    R = 6371.0

    # Convert latitude and longitude from degrees to radians
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])

    # Haversine formula
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    distance = R * c  # Result in kilometers
    return distance

# Step 2: Create a graph for the locations (12 nodes)
G = nx.Graph()

# Adding nodes (locations)
for loc in locations:
    G.add_node(loc["Location ID"], pos=(loc["Latitude"], loc["Longitude"]))

# Create edges between nodes with the distance as the weight
for i in range(len(locations)):
    for j in range(i+1, len(locations)):
        loc_i = locations[i]["Location ID"]
        loc_j = locations[j]["Location ID"]

        # Get the latitude and longitude of the two locations
        lat1, lon1 = locations[i]["Latitude"], locations[i]["Longitude"]
        lat2, lon2 = locations[j]["Latitude"], locations[j]["Longitude"]

        # Calculate the distance between the two locations using Haversine formula
        distance = haversine(lat1, lon1, lat2, lon2)

        # Add edge with distance as the weight
        G.add_edge(loc_i, loc_j, weight=distance)

# Step 3: Find the shortest path based on distance
def find_best_path(G, source, destination):
    # Use Dijkstra's algorithm to find the best path minimizing distance (lowest weight)
    path = nx.dijkstra_path(G, source, destination, weight="weight")
    path_weight = nx.dijkstra_path_length(G, source, destination, weight="weight")
    return path, path_weight

# Example: Find the best path from New York (1) to Tokyo (5)
source = 1  # New York
destination = 5  # Tokyo
best_path, distance = find_best_path(G, source, destination)

print(f"Best path from {source} to {destination}: {best_path} with distance: {distance} km")

# Step 4: Visualization (Map view)
# Create a folium map centered around the average location
average_lat = np.mean([loc["Latitude"] for loc in locations])
average_lon = np.mean([loc["Longitude"] for loc in locations])

map = folium.Map(location=[average_lat, average_lon], zoom_start=2)

# Add markers for the locations
for loc in locations:
    folium.Marker(
        location=[loc["Latitude"], loc["Longitude"]],
        popup=f"Location {loc['Location ID']}",
    ).add_to(map)

# Plot the path on the map
for i in range(len(best_path) - 1):
    loc1 = best_path[i]
    loc2 = best_path[i + 1]
    
    # Get coordinates of the locations
    lat1, lon1 = locations[loc1 - 1]["Latitude"], locations[loc1 - 1]["Longitude"]
    lat2, lon2 = locations[loc2 - 1]["Latitude"], locations[loc2 - 1]["Longitude"]
    
    # Add a line to represent the path between locations (distance-based)
    folium.PolyLine([(lat1, lon1), (lat2, lon2)], color="blue", weight=2.5, opacity=1).add_to(map)

# Save the map as an HTML file
map.save("best_path_map.html")

# Step 5: Visualization (Bar Plot for distances)
distance_counts = {}
for state in G.edges:
    distance = G[state[0]][state[1]]["weight"]
    if distance > 0:
        distance_counts[state] = distance

# Plot the distances between locations
plt.figure(figsize=(10, 6))
plt.hist(list(distance_counts.values()), bins=20, color='blue', edgecolor='black')
plt.title("Distribution of Distances Between Locations")
plt.xlabel("Distance (km)")
plt.ylabel("Frequency")
plt.show()
